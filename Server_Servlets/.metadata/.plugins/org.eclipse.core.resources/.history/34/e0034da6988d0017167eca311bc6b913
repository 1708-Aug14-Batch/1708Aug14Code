package com.reimburse.dao;

import java.math.BigDecimal;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.time.LocalDate;
import java.util.ArrayList;

import com.reimburse.pojos.*;
import com.reimburse.pojos.Account.accountLevel;
import com.reimburse.util.ConnectionFactory;

// NOTE: SQL is 1-indexed rather than 0-indexed
// FIXME remove redundant code

public class DaoImpl implements Dao {

	// Database reference: TO_TIMESTAMP(:ts_val, 'YYYY-MM-DD HH24:MI:SS')
	public String getFormattedTimestamp(LocalDate day) {
		if (day == null)
			return null;
		return day.toString();
	}
	public LocalDate fromFormattedTimestamp(String str) {
		if (str == null || str.equals("null"))
			return null;

		return LocalDate.parse(str.substring(0, 10));
	}

	public Worker createWorker(String firstName, String lastName, String email,
			String username, String password, boolean isManager, boolean isHired) {
		Worker work = null;

		try(Connection conn = ConnectionFactory.getInstance().getConnection()) {
			conn.setAutoCommit(false);

			// No semi-colon inside the quotes
			String sql = "INSERT INTO worker(first_name, last_name, email, username, password, is_manager, is_hired)" + 
					" VALUES(?, ?, ?, ?)";
			String[] key = new String[1];
			key[0] = "worker_id";

			PreparedStatement ps = conn.prepareStatement(sql, key);
			ps.setString(1, firstName);
			ps.setString(2, lastName);
			ps.setString(3, email);
			ps.setString(4, username);
			ps.setString(5, password);
			ps.setInt(6, isManager?1:0);
			ps.setInt(7, isHired?1:0);

			// executeUpdate() returns the number of rows updated
			ps.executeUpdate();

			int id = 0;
			ResultSet pk = ps.getGeneratedKeys();
			while(pk.next())
				id = pk.getInt(1);

			conn.commit();
			work = new Worker(id, firstName, lastName, email, username, password, isManager, isHired);

		} catch (SQLException e) {
			System.out.println("Database error");
		}

		return work;

	}

	public Person createPerson(String firstName, String lastName, String email, LocalDate birthDate, boolean deceased) {
		Person per = null;

		if (birthDate == null)
			return createPerson(firstName, lastName, email, deceased);

		try(Connection conn = ConnectionFactory.getInstance().getConnection()) {
			conn.setAutoCommit(false);

			// No semi-colon inside the quotes
			String sql = "INSERT INTO person(first_name, last_name, email, birth_date, deceased)" + 
					" VALUES(?, ?, ?, TO_DATE(?,'yyyy-mm-dd'), ?)";
			String[] key = new String[1];
			key[0] = "worker_id";

			PreparedStatement ps = conn.prepareStatement(sql, key);
			ps.setString(1, firstName);
			ps.setString(2, lastName);
			ps.setString(3, email);
			ps.setString(4, getFormattedDate(birthDate));
			ps.setInt(5, deceased?1:0);

			// executeUpdate() returns the number of rows updated
			ps.executeUpdate();

			int id = 0;
			ResultSet pk = ps.getGeneratedKeys();
			while(pk.next())
				id = pk.getInt(1);

			conn.commit();
			per = new Person(id, firstName, lastName, email);
			per.setBirthDate(birthDate);
			per.setDeceased(deceased);

		} catch (SQLException e) {
			System.out.println("Database error");
		}

		return per;

	}

	@Override
	public Person readPerson(int personId) {
		Person per = null;

		try(Connection conn = ConnectionFactory.getInstance().getConnection()) {

			String sql = "SELECT * FROM person WHERE worker_id=?";
			String[] key = new String[1];
			key[0] = "worker_id";

			PreparedStatement ps = conn.prepareStatement(sql, key);
			ps.setInt(1, personId);

			ResultSet rs = ps.executeQuery();

			while(rs.next()) {
				personId = rs.getInt(1);		// This line is redundant
				String firstName = rs.getString(2);
				String lastName = rs.getString(3);
				String email = rs.getString(4);
				LocalDate birthDate = fromFormattedDate(rs.getString(5));
				boolean deceased = (rs.getInt(6) == 0)?false:true;

				per = new Person(personId, firstName, lastName, email);
				per.setBirthDate(birthDate);
				per.setDeceased(deceased);
			}
		} catch (SQLException e) {
			System.out.println("Database error");
		}

		return per;
	}

	public Person readPerson(String email) {
		Person per = null;

		try(Connection conn = ConnectionFactory.getInstance().getConnection()) {

			String sql = "SELECT * FROM person WHERE email=?";
			String[] key = new String[1];
			key[0] = "worker_id";

			PreparedStatement ps = conn.prepareStatement(sql, key);
			ps.setString(1, email);

			ResultSet rs = ps.executeQuery();

			while(rs.next()) {
				int personId = rs.getInt(1);
				String firstName = rs.getString(2);
				String lastName = rs.getString(3);
				email = rs.getString(4);		// This line is redundant
				LocalDate birthDate = fromFormattedDate(rs.getString(5));
				boolean deceased = (rs.getInt(6) == 0)?false:true;

				per = new Person(personId, firstName, lastName, email);
				per.setBirthDate(birthDate);
				per.setDeceased(deceased);
			}
		} catch (SQLException e) {
			System.out.println("Database error");
		}

		return per;
	}

	@Override
	public boolean updatePerson(int personId, Person per) {

		try(Connection conn = ConnectionFactory.getInstance().getConnection()) {
			conn.setAutoCommit(false);

			// No semi-colon inside the quotes
			String sql = "UPDATE person SET" + 
					" first_name=?, last_name=?, email=?, birth_date=TO_DATE(?,'yyyy-mm-dd'), deceased=?" + 
					" WHERE worker_id=?";
			String[] key = new String[1];
			key[0] = "worker_id";

			PreparedStatement ps = conn.prepareStatement(sql, key);
			ps.setString(1, per.getFirstName());
			ps.setString(2, per.getLastName());
			ps.setString(3, per.getEmail());
			ps.setString(4, getFormattedDate(per.getBirthDate()));
			ps.setInt(5, per.isDeceased()?1:0);
			ps.setInt(6, personId);

			// executeUpdate() returns the number of rows updated
			ps.executeUpdate();

			conn.commit();
			return true;

		} catch (SQLException e) {
			System.out.println("Database error");
		}

		return false;

	}

	@Override
	public boolean deletePerson(int personId) {

		Person per = readPerson(personId);
		if (per == null)
			return false;

		per.setDeceased(true);
		return updatePerson(personId, per);

	}

	@Override
	public ArrayList<Person> readAllPersons() {
		ArrayList<Person> list = new ArrayList<Person>();

		try(Connection conn = ConnectionFactory.getInstance().getConnection()) {

			String sql = "SELECT * from person";
			Statement statement = conn.createStatement();
			ResultSet rs = statement.executeQuery(sql);

			while(rs.next()) {
				int personId = rs.getInt(1);
				String firstName = rs.getString(2);
				String lastName = rs.getString(3);
				String email = rs.getString(4);
				LocalDate birthDate = fromFormattedDate(rs.getString(5));
				boolean deceased = (rs.getInt(6) == 0)?false:true;

				Person per = new Person(personId, firstName, lastName, email);
				per.setBirthDate(birthDate);
				per.setDeceased(deceased);

				list.add(per);
			}
		} catch (SQLException e) {
			System.out.println("Database error");
		}

		return list;
	}

	@Override
	public Account createAccount(int reimbursementId, int submitterId,
			int statusId, LocalDate submitDate, String description) {
		Account acc = null;

		try(Connection conn = ConnectionFactory.getInstance().getConnection()) {
			conn.setAutoCommit(false);

			String sql = "INSERT INTO account(balance, opened_date, user_id, type_id, level_id, deleted)" + 
					" VALUES(?, TO_DATE(?,'yyyy-mm-dd'), ?, ?, ?, ?)";
			String[] key = new String[1];
			key[0] = "reimbursement_id";

			PreparedStatement ps = conn.prepareStatement(sql, key);
			ps.setString(1, balance.toString());
			LocalDate day = LocalDate.now();
			ps.setString(2, getFormattedDate(day));
			ps.setInt(3, guy.getUserId());
			ps.setInt(4, type.ordinal());
			ps.setInt(5, level.ordinal());
			ps.setInt(6, 0);		// false

			// executeUpdate() returns the number of rows updated
			ps.executeUpdate();

			Integer id = 0;
			ResultSet pk = ps.getGeneratedKeys();
			while(pk.next())
				id = pk.getInt(1);

			conn.commit();
			acc = new Account(id, day, balance, false, type, level, guy.getUserId());

		} catch (SQLException e) {
			System.out.println("Database error");
		}

		// Something went wrong
		return acc;

	}

	@Override
	public Account readAccount(int accountId) {
		Account acc = null;

		try(Connection conn = ConnectionFactory.getInstance().getConnection()) {

			String sql = "SELECT * FROM account WHERE reimbursement_id=?";
			String[] key = new String[1];
			key[0] = "reimbursement_id";

			PreparedStatement ps = conn.prepareStatement(sql, key);
			ps.setInt(1, accountId);

			ResultSet rs = ps.executeQuery();

			while(rs.next()) {
				accountId = rs.getInt(1);		// This line is redundant
				BigDecimal balance = new BigDecimal(rs.getString(2));
				LocalDate accountOpenedDate = fromFormattedDate(rs.getString(3));
				int userId = rs.getInt(4);
				int typeId = rs.getInt(5);
				int levelId = rs.getInt(6);
				boolean deleted = (rs.getInt(7) == 0)?false:true;

				acc = new Account(accountId, accountOpenedDate, balance, deleted, accountType.values()[typeId], accountLevel.values()[levelId], userId);

			}
		} catch (SQLException e) {
			System.out.println("Database error");
		}

		return acc;
	}

	@Override
	public boolean updateAccount(int accountId, Account acc) {
		try(Connection conn = ConnectionFactory.getInstance().getConnection()) {
			conn.setAutoCommit(false);

			// No semi-colon inside the quotes
			String sql = "UPDATE account SET" + 
					" balance=?, level_id=?, deleted=?" + 
					" WHERE reimbursement_id=?";
			String[] key = new String[1];
			key[0] = "reimbursement_id";

			PreparedStatement ps = conn.prepareStatement(sql, key);
			ps.setString(1, acc.getBalance().toString());
			ps.setInt(2, acc.getLevel().ordinal());
			ps.setInt(3, acc.isDeleted()?1:0);
			ps.setInt(4, accountId);

			// executeUpdate() returns the number of rows updated
			ps.executeUpdate();

			conn.commit();
			return true;

		} catch (SQLException e) {
			System.out.println("Database error");
		}

		return false;

	}

	@Override
	public boolean deleteAccount(int accountId) {

		Account acc = readAccount(accountId);
		if (acc == null)
			return false;

		acc.setDeleted(true);
		return updateAccount(accountId, acc);

	}

	@Override
	public ArrayList<Account> readAllAccounts() {
		ArrayList<Account> list = new ArrayList<Account>();

		try(Connection conn = ConnectionFactory.getInstance().getConnection()) {

			String sql = "SELECT * from account";
			Statement statement = conn.createStatement();
			ResultSet rs = statement.executeQuery(sql);

			while(rs.next()) {
				int accountId = rs.getInt(1);		// This line is redundant
				BigDecimal balance = new BigDecimal(rs.getString(2));
				LocalDate accountOpenedDate = fromFormattedDate(rs.getString(3));
				int userId = rs.getInt(4);
				int typeId = rs.getInt(5);
				int levelId = rs.getInt(6);
				boolean deleted = (rs.getInt(7) == 0)?false:true;

				Account acc = new Account(accountId, accountOpenedDate, balance, deleted, accountType.values()[typeId], accountLevel.values()[levelId], userId);

				list.add(acc);
			}
		} catch (SQLException e) {
			System.out.println("Database error");
		}

		return list;
	}

	@Override
	public ArrayList<Account> readAllAccounts(int userId) {
		ArrayList<Account> list = new ArrayList<Account>();

		try(Connection conn = ConnectionFactory.getInstance().getConnection()) {

			String sql = "SELECT * from account WHERE user_id=?";
			String[] key = new String[1];
			key[0] = "user_id";

			PreparedStatement ps = conn.prepareStatement(sql, key);
			ps.setInt(1, userId);

			ResultSet rs = ps.executeQuery();

			while(rs.next()) {
				int accountId = rs.getInt(1);		// This line is redundant
				BigDecimal balance = new BigDecimal(rs.getString(2));
				LocalDate accountOpenedDate = fromFormattedDate(rs.getString(3));
				userId = rs.getInt(4);
				int typeId = rs.getInt(5);
				int levelId = rs.getInt(6);
				boolean deleted = (rs.getInt(7) == 0)?false:true;

				Account acc = new Account(accountId, accountOpenedDate, balance, deleted, accountType.values()[typeId], accountLevel.values()[levelId], userId);

				list.add(acc);
			}
		} catch (SQLException e) {
			System.out.println("Database error");
		}

		return list;
	}

}
